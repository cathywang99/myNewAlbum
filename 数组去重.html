<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>数组去重</title>
</head>

<body>
    <script>
        let ary = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3]; //=>[1,2,3]
        /*   let newAry=[];
          ary.forEach(item=>{
              if(newAry.includes(item)) return;
              newAry.push(item);
          })
          console.log(newAry); */

        /* for(var i=0;i<ary.length;i++) {
            //item:每一次循环拿出来的当前项
            //i：当前项的索引，i+1：后一项的索引
            var item = ary[i];
            //让当前项和后面的每一项进行比较
            for(var j=i+1;j<ary.length;j++) {
                //compare:后面拿出来要比较的每一项
                var compare = ary[j];
                //如果compare和item相等，说明这一项是重复的，将其删掉
                if(compare===item) {
                    //j索引这一项要从数组中移除
                     ary.splice(j,1);
                     //数组塌陷了，j后面的每一项索引都提前了一位，下一次要比较的应该还是j这个索引的内容
                     j--;
                }
            }
        } */


//基于对象的数组去重的优秀的方法，性能较好
//1.创建一个空对象
function unique(ary) {
    let obj = {};
    //2.循环数组中的每一项，把每一项向对象中进行存储  =>ietm：item
    for (let i = 0; i < ary.length; i++) {
        let item = ary[i];
        //3.每一次存储之前进行判断：验证obj中是否存在这一项
        if (obj[item] !== undefined) {
            //已经存在这一项
            // ary.splice(i, 1);
            ary[i] = ary[ary.length - 1];
            ary.length--;
            i--;
            continue;
        }
        obj[item] = item; //obj[1]=1;  obj[2]=2;
    }
    return ary;
}
console.log(unique(ary));

        //基于splice实现删除性能不好：当前项被删除后，后面每一项的索引都要向前移一位，如果后面内容过多，一定影响性能。
    </script>
</body>

</html>