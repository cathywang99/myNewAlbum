<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>二叉搜索树</title>
</head>

<body>
    <script>
        function BinarySearchTree() {
            //创建内部类
            function Node(key) {
                this.key = key;
                this.left = null;
                this.right = null;
            }
            //属性
            this.root = null;

            //方法
            //1.插入数据：对外给用户调用的方法
            BinarySearchTree.prototype.insert = function (key) {
                //1.根据key创建节点,newNode是想要插入的节点
                var newNode = new Node(key);

                //2.判断根节点是否有值
                if (this.root == null) {
                    this.root = newNode;
                } else {
                    this.insertNode(this.root, newNode);
                }
            }

            //内部方法,递归实现
            //
            BinarySearchTree.prototype.insertNode = function (node, newNode) {
                if (newNode.key < node.key) { //向左查找
                    if (node.left == null) {
                        node.left = newNode; //没有这个节点，直接将左节点变成newNode
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else { //向右查找
                if (node.right == null) {
                        node.right == newNode;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }

            //树的遍历
            //1.先序遍历
            BinarySearchTree.prototype.preOrderTraversal = function (handler) {
                this.preOrderTraversalNode(this.root, handler);
            }
            BinarySearchTree.prototype.preOrderTraversalNode = function (node,handler) {
                if (node != null) {
                    //1.处理经过的节点
                    handler(node.key);
                    //2.处理经过节点的左子节点
                    this.preOrderTraversalNode(node.left, handler);
                    //3.处理经过节点的右子节点
                    this.preOrderTraversalNode(node.right, handler);
                }
            }

           /*  //2.中序遍历
            BinarySearchTree.prototype.midOrderTraversal = function (handler) {
                this.midOrderTraversalNode(this.root, handler);
            }
            BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) {
                if (node != null) {
                    //1.处理左子树的节点
                    this.midOrderTraversalNode(node.left, handler);
                    //2.处理节点
                    handler(node.key);
                    //3.处理右子树的节点
                    this.midOrderTraversalNode(node.right, handler);
                }
            } 
  */
        }

        var bst = new BinarySearchTree();
        bst.insert(11);
        bst.insert(7);
        bst.insert(15);
        bst.insert(3);
        bst.insert(9);
        bst.insert(8);
        bst.insert(10);
        bst.insert(13);
        bst.insert(12);
        bst.insert(14);
        bst.insert(20);
        bst.insert(18);
        bst.insert(25);
        bst.insert(6);
        console.log(bst);

       /*  //3.1测试先序遍历
        var resultString = '';
        bst.preOrderTraversal(function (key) {
            resultString += key + ' ';
        })
        alert(resultString); */

        /* //3.2测试中序遍历
        resultString = '';
        bst.midOrderTraversal(function (key) {
            resultString += key + ' ';
        })
        alert(resultString); */
    </script>
</body>

</html>